// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: github.com/infobloxopen/atlas-contacts-app/pkg/pb/contacts.proto

// Generated with protoc-gen-gorm version: master
// Anticipating compatibility with atlas-app-toolkit version: master

/*
Package pb is a generated protocol buffer package.

It is generated from these files:
	github.com/infobloxopen/atlas-contacts-app/pkg/pb/contacts.proto

It has these top-level messages:
	Profile
	CreateProfileRequest
	CreateProfileResponse
	ReadProfileRequest
	ReadProfileResponse
	UpdateProfileRequest
	UpdateProfileResponse
	DeleteProfileRequest
	DeleteProfileResponse
	ListProfileRequest
	ListProfilesResponse
	Group
	CreateGroupRequest
	CreateGroupResponse
	ReadGroupRequest
	ReadGroupResponse
	UpdateGroupRequest
	UpdateGroupResponse
	DeleteGroupRequest
	DeleteGroupResponse
	ListGroupRequest
	ListGroupsResponse
	Contact
	Email
	Address
	CreateContactRequest
	CreateContactResponse
	ReadContactRequest
	ReadContactResponse
	UpdateContactRequest
	UpdateContactResponse
	DeleteContactRequest
	DeleteContactResponse
	ListContactsResponse
	SMSRequest
	SMSResponse
	ListContactRequest
*/
package pb

import context "context"
import errors "errors"
import strings "strings"

import auth1 "github.com/infobloxopen/atlas-app-toolkit/auth"
import field_mask1 "google.golang.org/genproto/protobuf/field_mask"
import gorm1 "github.com/jinzhu/gorm"
import gorm2 "github.com/infobloxopen/atlas-app-toolkit/gorm"
import postgres1 "github.com/jinzhu/gorm/dialects/postgres"
import query1 "github.com/infobloxopen/atlas-app-toolkit/query"
import resource1 "github.com/infobloxopen/atlas-app-toolkit/gorm/resource"
import types1 "github.com/infobloxopen/protoc-gen-gorm/types"

import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/protobuf/field_mask"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import _ "github.com/lyft/protoc-gen-validate/validate"
import _ "github.com/grpc-ecosystem/grpc-gateway/protoc-gen-swagger/options"
import _ "github.com/infobloxopen/atlas-app-toolkit/query"
import _ "github.com/infobloxopen/atlas-app-toolkit/rpc/resource"

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf
var _ = math.Inf

type ProfileORM struct {
	AccountID string
	Contacts  []*ContactORM `gorm:"foreignkey:ProfileId;association_foreignkey:Id"`
	Groups    []*GroupORM   `gorm:"foreignkey:ProfileId;association_foreignkey:Id"`
	Id        int64         `gorm:"type:serial;primary_key"`
	Name      string
	Notes     string
}

// TableName overrides the default tablename generated by GORM
func (ProfileORM) TableName() string {
	return "profiles"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Profile) ToORM(ctx context.Context) (ProfileORM, error) {
	to := ProfileORM{}
	var err error
	if prehook, ok := interface{}(m).(ProfileWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.DecodeInt64(&Profile{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Notes = m.Notes
	for _, v := range m.Contacts {
		if v != nil {
			if tempContacts, cErr := v.ToORM(ctx); cErr == nil {
				to.Contacts = append(to.Contacts, &tempContacts)
			} else {
				return to, cErr
			}
		} else {
			to.Contacts = append(to.Contacts, nil)
		}
	}
	for _, v := range m.Groups {
		if v != nil {
			if tempGroups, cErr := v.ToORM(ctx); cErr == nil {
				to.Groups = append(to.Groups, &tempGroups)
			} else {
				return to, cErr
			}
		} else {
			to.Groups = append(to.Groups, nil)
		}
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(ProfileWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ProfileORM) ToPB(ctx context.Context) (Profile, error) {
	to := Profile{}
	var err error
	if prehook, ok := interface{}(m).(ProfileWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&Profile{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Notes = m.Notes
	for _, v := range m.Contacts {
		if v != nil {
			if tempContacts, cErr := v.ToPB(ctx); cErr == nil {
				to.Contacts = append(to.Contacts, &tempContacts)
			} else {
				return to, cErr
			}
		} else {
			to.Contacts = append(to.Contacts, nil)
		}
	}
	for _, v := range m.Groups {
		if v != nil {
			if tempGroups, cErr := v.ToPB(ctx); cErr == nil {
				to.Groups = append(to.Groups, &tempGroups)
			} else {
				return to, cErr
			}
		} else {
			to.Groups = append(to.Groups, nil)
		}
	}
	if posthook, ok := interface{}(m).(ProfileWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Profile the arg will be the target, the caller the one being converted from

// ProfileBeforeToORM called before default ToORM code
type ProfileWithBeforeToORM interface {
	BeforeToORM(context.Context, *ProfileORM) error
}

// ProfileAfterToORM called after default ToORM code
type ProfileWithAfterToORM interface {
	AfterToORM(context.Context, *ProfileORM) error
}

// ProfileBeforeToPB called before default ToPB code
type ProfileWithBeforeToPB interface {
	BeforeToPB(context.Context, *Profile) error
}

// ProfileAfterToPB called after default ToPB code
type ProfileWithAfterToPB interface {
	AfterToPB(context.Context, *Profile) error
}

type GroupORM struct {
	AccountID string
	Contacts  []*ContactORM `gorm:"foreignkey:Id;association_foreignkey:Id;many2many:group_contacts;jointable_foreignkey:group_id;association_jointable_foreignkey:contact_id"`
	Id        int64         `gorm:"type:serial;primary_key"`
	Name      string
	Notes     string
	ProfileId *int64
}

// TableName overrides the default tablename generated by GORM
func (GroupORM) TableName() string {
	return "groups"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Group) ToORM(ctx context.Context) (GroupORM, error) {
	to := GroupORM{}
	var err error
	if prehook, ok := interface{}(m).(GroupWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.DecodeInt64(&Group{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Notes = m.Notes
	if m.ProfileId != nil {
		if v, err := resource1.DecodeInt64(&Profile{}, m.ProfileId); err != nil {
			return to, err
		} else {
			to.ProfileId = &v
		}
	}
	for _, v := range m.Contacts {
		if v != nil {
			if tempContacts, cErr := v.ToORM(ctx); cErr == nil {
				to.Contacts = append(to.Contacts, &tempContacts)
			} else {
				return to, cErr
			}
		} else {
			to.Contacts = append(to.Contacts, nil)
		}
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(GroupWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *GroupORM) ToPB(ctx context.Context) (Group, error) {
	to := Group{}
	var err error
	if prehook, ok := interface{}(m).(GroupWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&Group{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Notes = m.Notes
	if m.ProfileId != nil {
		if v, err := resource1.Encode(&Profile{}, *m.ProfileId); err != nil {
			return to, err
		} else {
			to.ProfileId = v
		}
	}
	for _, v := range m.Contacts {
		if v != nil {
			if tempContacts, cErr := v.ToPB(ctx); cErr == nil {
				to.Contacts = append(to.Contacts, &tempContacts)
			} else {
				return to, cErr
			}
		} else {
			to.Contacts = append(to.Contacts, nil)
		}
	}
	if posthook, ok := interface{}(m).(GroupWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Group the arg will be the target, the caller the one being converted from

// GroupBeforeToORM called before default ToORM code
type GroupWithBeforeToORM interface {
	BeforeToORM(context.Context, *GroupORM) error
}

// GroupAfterToORM called after default ToORM code
type GroupWithAfterToORM interface {
	AfterToORM(context.Context, *GroupORM) error
}

// GroupBeforeToPB called before default ToPB code
type GroupWithBeforeToPB interface {
	BeforeToPB(context.Context, *Group) error
}

// GroupAfterToPB called after default ToPB code
type GroupWithAfterToPB interface {
	AfterToPB(context.Context, *Group) error
}

type ContactORM struct {
	AccountID   string
	Emails      []*EmailORM `gorm:"foreignkey:ContactId;association_foreignkey:Id"`
	FirstName   string
	Groups      []*GroupORM `gorm:"foreignkey:Id;association_foreignkey:Id;many2many:group_contacts;jointable_foreignkey:contact_id;association_jointable_foreignkey:group_id"`
	HomeAddress *AddressORM `gorm:"foreignkey:HomeAddressContactId;association_foreignkey:Id"`
	Id          int64       `gorm:"type:serial;primary_key"`
	LastName    string
	MiddleName  string
	Nicknames   *postgres1.Jsonb `gorm:"type:jsonb"`
	Notes       string
	ProfileId   *int64
	WorkAddress *AddressORM `gorm:"foreignkey:WorkAddressContactId;association_foreignkey:Id"`
}

// TableName overrides the default tablename generated by GORM
func (ContactORM) TableName() string {
	return "contacts"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Contact) ToORM(ctx context.Context) (ContactORM, error) {
	to := ContactORM{}
	var err error
	if prehook, ok := interface{}(m).(ContactWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.DecodeInt64(&Contact{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.FirstName = m.FirstName
	to.MiddleName = m.MiddleName
	to.LastName = m.LastName
	to.Notes = m.Notes
	for _, v := range m.Emails {
		if v != nil {
			if tempEmails, cErr := v.ToORM(ctx); cErr == nil {
				to.Emails = append(to.Emails, &tempEmails)
			} else {
				return to, cErr
			}
		} else {
			to.Emails = append(to.Emails, nil)
		}
	}
	if m.HomeAddress != nil {
		tempHomeAddress, err := m.HomeAddress.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.HomeAddress = &tempHomeAddress
	}
	if m.WorkAddress != nil {
		tempWorkAddress, err := m.WorkAddress.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.WorkAddress = &tempWorkAddress
	}
	if m.ProfileId != nil {
		if v, err := resource1.DecodeInt64(&Profile{}, m.ProfileId); err != nil {
			return to, err
		} else {
			to.ProfileId = &v
		}
	}
	for _, v := range m.Groups {
		if v != nil {
			if tempGroups, cErr := v.ToORM(ctx); cErr == nil {
				to.Groups = append(to.Groups, &tempGroups)
			} else {
				return to, cErr
			}
		} else {
			to.Groups = append(to.Groups, nil)
		}
	}
	if m.Nicknames != nil {
		to.Nicknames = &postgres1.Jsonb{[]byte(m.Nicknames.Value)}
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(ContactWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ContactORM) ToPB(ctx context.Context) (Contact, error) {
	to := Contact{}
	var err error
	if prehook, ok := interface{}(m).(ContactWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&Contact{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.FirstName = m.FirstName
	to.MiddleName = m.MiddleName
	to.LastName = m.LastName
	to.Notes = m.Notes
	for _, v := range m.Emails {
		if v != nil {
			if tempEmails, cErr := v.ToPB(ctx); cErr == nil {
				to.Emails = append(to.Emails, &tempEmails)
			} else {
				return to, cErr
			}
		} else {
			to.Emails = append(to.Emails, nil)
		}
	}
	if m.HomeAddress != nil {
		tempHomeAddress, err := m.HomeAddress.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.HomeAddress = &tempHomeAddress
	}
	if m.WorkAddress != nil {
		tempWorkAddress, err := m.WorkAddress.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.WorkAddress = &tempWorkAddress
	}
	if m.ProfileId != nil {
		if v, err := resource1.Encode(&Profile{}, *m.ProfileId); err != nil {
			return to, err
		} else {
			to.ProfileId = v
		}
	}
	for _, v := range m.Groups {
		if v != nil {
			if tempGroups, cErr := v.ToPB(ctx); cErr == nil {
				to.Groups = append(to.Groups, &tempGroups)
			} else {
				return to, cErr
			}
		} else {
			to.Groups = append(to.Groups, nil)
		}
	}
	if m.Nicknames != nil {
		to.Nicknames = &types1.JSONValue{Value: string(m.Nicknames.RawMessage)}
	}
	if posthook, ok := interface{}(m).(ContactWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Contact the arg will be the target, the caller the one being converted from

// ContactBeforeToORM called before default ToORM code
type ContactWithBeforeToORM interface {
	BeforeToORM(context.Context, *ContactORM) error
}

// ContactAfterToORM called after default ToORM code
type ContactWithAfterToORM interface {
	AfterToORM(context.Context, *ContactORM) error
}

// ContactBeforeToPB called before default ToPB code
type ContactWithBeforeToPB interface {
	BeforeToPB(context.Context, *Contact) error
}

// ContactAfterToPB called after default ToPB code
type ContactWithAfterToPB interface {
	AfterToPB(context.Context, *Contact) error
}

type EmailORM struct {
	AccountID string
	Address   string `gorm:"unique"`
	ContactId *int64
	Id        uint64
	IsPrimary *bool
}

// TableName overrides the default tablename generated by GORM
func (EmailORM) TableName() string {
	return "emails"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Email) ToORM(ctx context.Context) (EmailORM, error) {
	to := EmailORM{}
	var err error
	if prehook, ok := interface{}(m).(EmailWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Address = m.Address
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(EmailWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *EmailORM) ToPB(ctx context.Context) (Email, error) {
	to := Email{}
	var err error
	if prehook, ok := interface{}(m).(EmailWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Address = m.Address
	if posthook, ok := interface{}(m).(EmailWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Email the arg will be the target, the caller the one being converted from

// EmailBeforeToORM called before default ToORM code
type EmailWithBeforeToORM interface {
	BeforeToORM(context.Context, *EmailORM) error
}

// EmailAfterToORM called after default ToORM code
type EmailWithAfterToORM interface {
	AfterToORM(context.Context, *EmailORM) error
}

// EmailBeforeToPB called before default ToPB code
type EmailWithBeforeToPB interface {
	BeforeToPB(context.Context, *Email) error
}

// EmailAfterToPB called after default ToPB code
type EmailWithAfterToPB interface {
	AfterToPB(context.Context, *Email) error
}

type AddressORM struct {
	AccountID            string
	Address              string
	City                 string
	Country              string
	HomeAddressContactId *int64
	State                string
	WorkAddressContactId *int64
	Zip                  string
}

// TableName overrides the default tablename generated by GORM
func (AddressORM) TableName() string {
	return "addresses"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Address) ToORM(ctx context.Context) (AddressORM, error) {
	to := AddressORM{}
	var err error
	if prehook, ok := interface{}(m).(AddressWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Address = m.Address
	to.City = m.City
	to.State = m.State
	to.Zip = m.Zip
	to.Country = m.Country
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(AddressWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *AddressORM) ToPB(ctx context.Context) (Address, error) {
	to := Address{}
	var err error
	if prehook, ok := interface{}(m).(AddressWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Address = m.Address
	to.City = m.City
	to.State = m.State
	to.Zip = m.Zip
	to.Country = m.Country
	if posthook, ok := interface{}(m).(AddressWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Address the arg will be the target, the caller the one being converted from

// AddressBeforeToORM called before default ToORM code
type AddressWithBeforeToORM interface {
	BeforeToORM(context.Context, *AddressORM) error
}

// AddressAfterToORM called after default ToORM code
type AddressWithAfterToORM interface {
	AfterToORM(context.Context, *AddressORM) error
}

// AddressBeforeToPB called before default ToPB code
type AddressWithBeforeToPB interface {
	BeforeToPB(context.Context, *Address) error
}

// AddressAfterToPB called after default ToPB code
type AddressWithAfterToPB interface {
	AfterToPB(context.Context, *Address) error
}

// DefaultCreateProfile executes a basic gorm create call
func DefaultCreateProfile(ctx context.Context, in *Profile, db *gorm1.DB) (*Profile, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultCreateProfile")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ProfileORMWithBeforeCreate); ok {
		if db, err = hook.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ProfileORMWithAfterCreate); ok {
		if err = hook.AfterCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ProfileORMWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ProfileORMWithAfterCreate interface {
	AfterCreate(context.Context, *gorm1.DB) error
}

// DefaultReadProfile executes a basic gorm read call
func DefaultReadProfile(ctx context.Context, in *Profile, db *gorm1.DB) (*Profile, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultReadProfile")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.New("DefaultReadProfile requires a non-zero primary key")
	}
	if hook, ok := interface{}(&ormObj).(ProfileORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &ProfileORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ProfileORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ProfileORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ProfileORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ProfileORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ProfileORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ProfileORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteProfile(ctx context.Context, in *Profile, db *gorm1.DB) error {
	if in == nil {
		return errors.New("Nil argument to DefaultDeleteProfile")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.New("A non-zero ID value is required for a delete call")
	}
	if hook, ok := interface{}(&ormObj).(ProfileORMWithBeforeDelete); ok {
		if db, err = hook.BeforeDelete(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ProfileORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ProfileORMWithAfterDelete); ok {
		err = hook.AfterDelete(ctx, db)
	}
	return err
}

type ProfileORMWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ProfileORMWithAfterDelete interface {
	AfterDelete(context.Context, *gorm1.DB) error
}

func DefaultDeleteProfileSet(ctx context.Context, in []*Profile, db *gorm1.DB) error {
	if in == nil {
		return errors.New("Nil argument to DefaultDeleteProfileSet")
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.New("A non-zero ID value is required for a delete call")
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ProfileORM{})).(ProfileORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&ProfileORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ProfileORM{})).(ProfileORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ProfileORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Profile, *gorm1.DB) (*gorm1.DB, error)
}
type ProfileORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Profile, *gorm1.DB) error
}

// DefaultStrictUpdateProfile clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateProfile(ctx context.Context, in *Profile, db *gorm1.DB) (*Profile, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateProfile")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	if hook, ok := interface{}(&ormObj).(ProfileORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterContacts := ContactORM{}
	if ormObj.Id == 0 {
		return nil, errors.New("Can't do overwriting update with no Id value for ProfileORM")
	}
	filterContacts.ProfileId = new(int64)
	*filterContacts.ProfileId = ormObj.Id
	if err = db.Where(filterContacts).Delete(ContactORM{}).Error; err != nil {
		return nil, err
	}
	filterGroups := GroupORM{}
	if ormObj.Id == 0 {
		return nil, errors.New("Can't do overwriting update with no Id value for ProfileORM")
	}
	filterGroups.ProfileId = new(int64)
	*filterGroups.ProfileId = ormObj.Id
	if err = db.Where(filterGroups).Delete(GroupORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ProfileORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ProfileORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ProfileORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ProfileORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ProfileORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchProfile executes a basic gorm update call with patch behavior
func DefaultPatchProfile(ctx context.Context, in *Profile, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Profile, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultPatchProfile")
	}
	var pbObj Profile
	var err error
	if hook, ok := interface{}(&pbObj).(ProfileWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadProfile(ctx, &Profile{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ProfileWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskProfile(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ProfileWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateProfile(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ProfileWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ProfileWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Profile, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ProfileWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Profile, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ProfileWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Profile, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ProfileWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Profile, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultApplyFieldMaskProfile patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskProfile(ctx context.Context, patchee *Profile, patcher *Profile, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Profile, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.New("Patchee inputs to DefaultApplyFieldMaskProfile must be non-nil")
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Notes" {
			patchee.Notes = patcher.Notes
			continue
		}
		if f == prefix+"Contacts" {
			patchee.Contacts = patcher.Contacts
			continue
		}
		if f == prefix+"Groups" {
			patchee.Groups = patcher.Groups
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListProfile executes a gorm list call
func DefaultListProfile(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*Profile, error) {
	in := Profile{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ProfileORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &ProfileORM{}, &Profile{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ProfileORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ProfileORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ProfileORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Profile{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ProfileORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ProfileORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ProfileORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]ProfileORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateGroup executes a basic gorm create call
func DefaultCreateGroup(ctx context.Context, in *Group, db *gorm1.DB) (*Group, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultCreateGroup")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupORMWithBeforeCreate); ok {
		if db, err = hook.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupORMWithAfterCreate); ok {
		if err = hook.AfterCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type GroupORMWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type GroupORMWithAfterCreate interface {
	AfterCreate(context.Context, *gorm1.DB) error
}

// DefaultReadGroup executes a basic gorm read call
func DefaultReadGroup(ctx context.Context, in *Group, db *gorm1.DB) (*Group, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultReadGroup")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.New("DefaultReadGroup requires a non-zero primary key")
	}
	if hook, ok := interface{}(&ormObj).(GroupORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &GroupORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := GroupORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(GroupORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type GroupORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type GroupORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type GroupORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteGroup(ctx context.Context, in *Group, db *gorm1.DB) error {
	if in == nil {
		return errors.New("Nil argument to DefaultDeleteGroup")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.New("A non-zero ID value is required for a delete call")
	}
	if hook, ok := interface{}(&ormObj).(GroupORMWithBeforeDelete); ok {
		if db, err = hook.BeforeDelete(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&GroupORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(GroupORMWithAfterDelete); ok {
		err = hook.AfterDelete(ctx, db)
	}
	return err
}

type GroupORMWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type GroupORMWithAfterDelete interface {
	AfterDelete(context.Context, *gorm1.DB) error
}

func DefaultDeleteGroupSet(ctx context.Context, in []*Group, db *gorm1.DB) error {
	if in == nil {
		return errors.New("Nil argument to DefaultDeleteGroupSet")
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.New("A non-zero ID value is required for a delete call")
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&GroupORM{})).(GroupORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&GroupORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&GroupORM{})).(GroupORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type GroupORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Group, *gorm1.DB) (*gorm1.DB, error)
}
type GroupORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Group, *gorm1.DB) error
}

// DefaultStrictUpdateGroup clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateGroup(ctx context.Context, in *Group, db *gorm1.DB) (*Group, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateGroup")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	if hook, ok := interface{}(&ormObj).(GroupORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(GroupORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type GroupORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type GroupORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type GroupORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchGroup executes a basic gorm update call with patch behavior
func DefaultPatchGroup(ctx context.Context, in *Group, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Group, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultPatchGroup")
	}
	var pbObj Group
	var err error
	if hook, ok := interface{}(&pbObj).(GroupWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadGroup(ctx, &Group{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(GroupWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskGroup(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(GroupWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateGroup(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(GroupWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type GroupWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Group, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type GroupWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Group, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type GroupWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Group, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type GroupWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Group, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultApplyFieldMaskGroup patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskGroup(ctx context.Context, patchee *Group, patcher *Group, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Group, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.New("Patchee inputs to DefaultApplyFieldMaskGroup must be non-nil")
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Notes" {
			patchee.Notes = patcher.Notes
			continue
		}
		if f == prefix+"ProfileId" {
			patchee.ProfileId = patcher.ProfileId
			continue
		}
		if f == prefix+"Contacts" {
			patchee.Contacts = patcher.Contacts
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListGroup executes a gorm list call
func DefaultListGroup(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*Group, error) {
	in := Group{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &GroupORM{}, &Group{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []GroupORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Group{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type GroupORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type GroupORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type GroupORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]GroupORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateContact executes a basic gorm create call
func DefaultCreateContact(ctx context.Context, in *Contact, db *gorm1.DB) (*Contact, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultCreateContact")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContactORMWithBeforeCreate); ok {
		if db, err = hook.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContactORMWithAfterCreate); ok {
		if err = hook.AfterCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ContactORMWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ContactORMWithAfterCreate interface {
	AfterCreate(context.Context, *gorm1.DB) error
}

// DefaultReadContact executes a basic gorm read call
func DefaultReadContact(ctx context.Context, in *Contact, db *gorm1.DB) (*Contact, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultReadContact")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.New("DefaultReadContact requires a non-zero primary key")
	}
	if hook, ok := interface{}(&ormObj).(ContactORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &ContactORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContactORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ContactORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ContactORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ContactORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ContactORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ContactORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteContact(ctx context.Context, in *Contact, db *gorm1.DB) error {
	if in == nil {
		return errors.New("Nil argument to DefaultDeleteContact")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.New("A non-zero ID value is required for a delete call")
	}
	if hook, ok := interface{}(&ormObj).(ContactORMWithBeforeDelete); ok {
		if db, err = hook.BeforeDelete(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ContactORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ContactORMWithAfterDelete); ok {
		err = hook.AfterDelete(ctx, db)
	}
	return err
}

type ContactORMWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ContactORMWithAfterDelete interface {
	AfterDelete(context.Context, *gorm1.DB) error
}

func DefaultDeleteContactSet(ctx context.Context, in []*Contact, db *gorm1.DB) error {
	if in == nil {
		return errors.New("Nil argument to DefaultDeleteContactSet")
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.New("A non-zero ID value is required for a delete call")
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ContactORM{})).(ContactORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&ContactORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ContactORM{})).(ContactORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ContactORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Contact, *gorm1.DB) (*gorm1.DB, error)
}
type ContactORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Contact, *gorm1.DB) error
}

// DefaultStrictUpdateContact clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateContact(ctx context.Context, in *Contact, db *gorm1.DB) (*Contact, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateContact")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	if hook, ok := interface{}(&ormObj).(ContactORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterEmails := EmailORM{}
	if ormObj.Id == 0 {
		return nil, errors.New("Can't do overwriting update with no Id value for ContactORM")
	}
	filterEmails.ContactId = new(int64)
	*filterEmails.ContactId = ormObj.Id
	if err = db.Where(filterEmails).Delete(EmailORM{}).Error; err != nil {
		return nil, err
	}
	filterHomeAddress := AddressORM{}
	if ormObj.Id == 0 {
		return nil, errors.New("Can't do overwriting update with no Id value for ContactORM")
	}
	filterHomeAddress.HomeAddressContactId = new(int64)
	*filterHomeAddress.HomeAddressContactId = ormObj.Id
	if err = db.Where(filterHomeAddress).Delete(AddressORM{}).Error; err != nil {
		return nil, err
	}
	filterWorkAddress := AddressORM{}
	if ormObj.Id == 0 {
		return nil, errors.New("Can't do overwriting update with no Id value for ContactORM")
	}
	filterWorkAddress.WorkAddressContactId = new(int64)
	*filterWorkAddress.WorkAddressContactId = ormObj.Id
	if err = db.Where(filterWorkAddress).Delete(AddressORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContactORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContactORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ContactORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ContactORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ContactORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchContact executes a basic gorm update call with patch behavior
func DefaultPatchContact(ctx context.Context, in *Contact, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Contact, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultPatchContact")
	}
	var pbObj Contact
	var err error
	if hook, ok := interface{}(&pbObj).(ContactWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadContact(ctx, &Contact{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ContactWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskContact(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ContactWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateContact(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ContactWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ContactWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Contact, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ContactWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Contact, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ContactWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Contact, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ContactWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Contact, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultApplyFieldMaskContact patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskContact(ctx context.Context, patchee *Contact, patcher *Contact, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Contact, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.New("Patchee inputs to DefaultApplyFieldMaskContact must be non-nil")
	}
	var err error
	var updatedHomeAddress bool
	var updatedWorkAddress bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"FirstName" {
			patchee.FirstName = patcher.FirstName
			continue
		}
		if f == prefix+"MiddleName" {
			patchee.MiddleName = patcher.MiddleName
			continue
		}
		if f == prefix+"LastName" {
			patchee.LastName = patcher.LastName
			continue
		}
		if f == prefix+"PrimaryEmail" {
			patchee.PrimaryEmail = patcher.PrimaryEmail
			continue
		}
		if f == prefix+"Notes" {
			patchee.Notes = patcher.Notes
			continue
		}
		if f == prefix+"Emails" {
			patchee.Emails = patcher.Emails
			continue
		}
		if strings.HasPrefix(f, prefix+"HomeAddress.") && !updatedHomeAddress {
			updatedHomeAddress = true
			if patcher.HomeAddress == nil {
				patchee.HomeAddress = nil
				continue
			}
			if patchee.HomeAddress == nil {
				patchee.HomeAddress = &Address{}
			}
			if o, err := DefaultApplyFieldMaskAddress(ctx, patchee.HomeAddress, patcher.HomeAddress, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"HomeAddress.", db); err != nil {
				return nil, err
			} else {
				patchee.HomeAddress = o
			}
			continue
		}
		if f == prefix+"HomeAddress" {
			updatedHomeAddress = true
			patchee.HomeAddress = patcher.HomeAddress
			continue
		}
		if strings.HasPrefix(f, prefix+"WorkAddress.") && !updatedWorkAddress {
			updatedWorkAddress = true
			if patcher.WorkAddress == nil {
				patchee.WorkAddress = nil
				continue
			}
			if patchee.WorkAddress == nil {
				patchee.WorkAddress = &Address{}
			}
			if o, err := DefaultApplyFieldMaskAddress(ctx, patchee.WorkAddress, patcher.WorkAddress, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"WorkAddress.", db); err != nil {
				return nil, err
			} else {
				patchee.WorkAddress = o
			}
			continue
		}
		if f == prefix+"WorkAddress" {
			updatedWorkAddress = true
			patchee.WorkAddress = patcher.WorkAddress
			continue
		}
		if f == prefix+"ProfileId" {
			patchee.ProfileId = patcher.ProfileId
			continue
		}
		if f == prefix+"Groups" {
			patchee.Groups = patcher.Groups
			continue
		}
		if f == prefix+"Nicknames" {
			patchee.Nicknames = patcher.Nicknames
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListContact executes a gorm list call
func DefaultListContact(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*Contact, error) {
	in := Contact{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContactORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &ContactORM{}, &Contact{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContactORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ContactORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContactORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Contact{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ContactORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ContactORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ContactORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]ContactORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateEmail executes a basic gorm create call
func DefaultCreateEmail(ctx context.Context, in *Email, db *gorm1.DB) (*Email, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultCreateEmail")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmailORMWithBeforeCreate); ok {
		if db, err = hook.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmailORMWithAfterCreate); ok {
		if err = hook.AfterCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type EmailORMWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type EmailORMWithAfterCreate interface {
	AfterCreate(context.Context, *gorm1.DB) error
}

// DefaultReadEmail executes a basic gorm read call
func DefaultReadEmail(ctx context.Context, in *Email, db *gorm1.DB) (*Email, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultReadEmail")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.New("DefaultReadEmail requires a non-zero primary key")
	}
	if hook, ok := interface{}(&ormObj).(EmailORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &EmailORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmailORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := EmailORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(EmailORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type EmailORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type EmailORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type EmailORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteEmail(ctx context.Context, in *Email, db *gorm1.DB) error {
	if in == nil {
		return errors.New("Nil argument to DefaultDeleteEmail")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.New("A non-zero ID value is required for a delete call")
	}
	if hook, ok := interface{}(&ormObj).(EmailORMWithBeforeDelete); ok {
		if db, err = hook.BeforeDelete(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&EmailORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(EmailORMWithAfterDelete); ok {
		err = hook.AfterDelete(ctx, db)
	}
	return err
}

type EmailORMWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type EmailORMWithAfterDelete interface {
	AfterDelete(context.Context, *gorm1.DB) error
}

func DefaultDeleteEmailSet(ctx context.Context, in []*Email, db *gorm1.DB) error {
	if in == nil {
		return errors.New("Nil argument to DefaultDeleteEmailSet")
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.New("A non-zero ID value is required for a delete call")
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&EmailORM{})).(EmailORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&EmailORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&EmailORM{})).(EmailORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type EmailORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Email, *gorm1.DB) (*gorm1.DB, error)
}
type EmailORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Email, *gorm1.DB) error
}

// DefaultStrictUpdateEmail clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateEmail(ctx context.Context, in *Email, db *gorm1.DB) (*Email, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateEmail")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	if hook, ok := interface{}(&ormObj).(EmailORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(EmailORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmailORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type EmailORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type EmailORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type EmailORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchEmail executes a basic gorm update call with patch behavior
func DefaultPatchEmail(ctx context.Context, in *Email, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Email, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultPatchEmail")
	}
	var pbObj Email
	var err error
	if hook, ok := interface{}(&pbObj).(EmailWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadEmail(ctx, &Email{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(EmailWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskEmail(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(EmailWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateEmail(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(EmailWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type EmailWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Email, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type EmailWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Email, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type EmailWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Email, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type EmailWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Email, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultApplyFieldMaskEmail patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskEmail(ctx context.Context, patchee *Email, patcher *Email, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Email, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.New("Patchee inputs to DefaultApplyFieldMaskEmail must be non-nil")
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Address" {
			patchee.Address = patcher.Address
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListEmail executes a gorm list call
func DefaultListEmail(ctx context.Context, db *gorm1.DB) ([]*Email, error) {
	in := Email{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmailORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &EmailORM{}, &Email{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmailORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []EmailORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmailORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Email{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type EmailORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type EmailORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type EmailORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]EmailORM) error
}

// DefaultCreateAddress executes a basic gorm create call
func DefaultCreateAddress(ctx context.Context, in *Address, db *gorm1.DB) (*Address, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultCreateAddress")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeCreate); ok {
		if db, err = hook.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithAfterCreate); ok {
		if err = hook.AfterCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type AddressORMWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AddressORMWithAfterCreate interface {
	AfterCreate(context.Context, *gorm1.DB) error
}

// DefaultApplyFieldMaskAddress patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskAddress(ctx context.Context, patchee *Address, patcher *Address, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Address, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.New("Patchee inputs to DefaultApplyFieldMaskAddress must be non-nil")
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Address" {
			patchee.Address = patcher.Address
			continue
		}
		if f == prefix+"City" {
			patchee.City = patcher.City
			continue
		}
		if f == prefix+"State" {
			patchee.State = patcher.State
			continue
		}
		if f == prefix+"Zip" {
			patchee.Zip = patcher.Zip
			continue
		}
		if f == prefix+"Country" {
			patchee.Country = patcher.Country
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListAddress executes a gorm list call
func DefaultListAddress(ctx context.Context, db *gorm1.DB) ([]*Address, error) {
	in := Address{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &AddressORM{}, &Address{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	ormResponse := []AddressORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Address{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type AddressORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AddressORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AddressORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]AddressORM) error
}
type ProfilesDefaultServer struct {
	DB *gorm1.DB
}

// Create ...
func (m *ProfilesDefaultServer) Create(ctx context.Context, in *CreateProfileRequest) (*CreateProfileResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ProfilesProfileWithBeforeCreate); ok {
		var err error
		if db, err = custom.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateProfile(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateProfileResponse{Result: res}
	if custom, ok := interface{}(in).(ProfilesProfileWithAfterCreate); ok {
		var err error
		if err = custom.AfterCreate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ProfilesProfileWithBeforeCreate called before DefaultCreateProfile in the default Create handler
type ProfilesProfileWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ProfilesProfileWithAfterCreate called before DefaultCreateProfile in the default Create handler
type ProfilesProfileWithAfterCreate interface {
	AfterCreate(context.Context, *CreateProfileResponse, *gorm1.DB) error
}

// Read ...
func (m *ProfilesDefaultServer) Read(ctx context.Context, in *ReadProfileRequest) (*ReadProfileResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ProfilesProfileWithBeforeRead); ok {
		var err error
		if db, err = custom.BeforeRead(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadProfile(ctx, &Profile{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &ReadProfileResponse{Result: res}
	if custom, ok := interface{}(in).(ProfilesProfileWithAfterRead); ok {
		var err error
		if err = custom.AfterRead(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ProfilesProfileWithBeforeRead called before DefaultReadProfile in the default Read handler
type ProfilesProfileWithBeforeRead interface {
	BeforeRead(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ProfilesProfileWithAfterRead called before DefaultReadProfile in the default Read handler
type ProfilesProfileWithAfterRead interface {
	AfterRead(context.Context, *ReadProfileResponse, *gorm1.DB) error
}

// Update ...
func (m *ProfilesDefaultServer) Update(ctx context.Context, in *UpdateProfileRequest) (*UpdateProfileResponse, error) {
	var err error
	var res *Profile
	db := m.DB
	if custom, ok := interface{}(in).(ProfilesProfileWithBeforeUpdate); ok {
		var err error
		if db, err = custom.BeforeUpdate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err = DefaultStrictUpdateProfile(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &UpdateProfileResponse{Result: res}
	if custom, ok := interface{}(in).(ProfilesProfileWithAfterUpdate); ok {
		var err error
		if err = custom.AfterUpdate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ProfilesProfileWithBeforeUpdate called before DefaultUpdateProfile in the default Update handler
type ProfilesProfileWithBeforeUpdate interface {
	BeforeUpdate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ProfilesProfileWithAfterUpdate called before DefaultUpdateProfile in the default Update handler
type ProfilesProfileWithAfterUpdate interface {
	AfterUpdate(context.Context, *UpdateProfileResponse, *gorm1.DB) error
}

// Delete ...
func (m *ProfilesDefaultServer) Delete(ctx context.Context, in *DeleteProfileRequest) (*DeleteProfileResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ProfilesProfileWithBeforeDelete); ok {
		var err error
		if db, err = custom.BeforeDelete(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteProfile(ctx, &Profile{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteProfileResponse{}
	if custom, ok := interface{}(in).(ProfilesProfileWithAfterDelete); ok {
		var err error
		if err = custom.AfterDelete(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ProfilesProfileWithBeforeDelete called before DefaultDeleteProfile in the default Delete handler
type ProfilesProfileWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ProfilesProfileWithAfterDelete called before DefaultDeleteProfile in the default Delete handler
type ProfilesProfileWithAfterDelete interface {
	AfterDelete(context.Context, *DeleteProfileResponse, *gorm1.DB) error
}

// List ...
func (m *ProfilesDefaultServer) List(ctx context.Context, in *ListProfileRequest) (*ListProfilesResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ProfilesProfileWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultListProfile(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ListProfilesResponse{Results: res}
	if custom, ok := interface{}(in).(ProfilesProfileWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ProfilesProfileWithBeforeList called before DefaultListProfile in the default List handler
type ProfilesProfileWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ProfilesProfileWithAfterList called before DefaultListProfile in the default List handler
type ProfilesProfileWithAfterList interface {
	AfterList(context.Context, *ListProfilesResponse, *gorm1.DB) error
}
type GroupsDefaultServer struct {
	DB *gorm1.DB
}

// Create ...
func (m *GroupsDefaultServer) Create(ctx context.Context, in *CreateGroupRequest) (*CreateGroupResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(GroupsGroupWithBeforeCreate); ok {
		var err error
		if db, err = custom.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateGroup(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateGroupResponse{Result: res}
	if custom, ok := interface{}(in).(GroupsGroupWithAfterCreate); ok {
		var err error
		if err = custom.AfterCreate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// GroupsGroupWithBeforeCreate called before DefaultCreateGroup in the default Create handler
type GroupsGroupWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// GroupsGroupWithAfterCreate called before DefaultCreateGroup in the default Create handler
type GroupsGroupWithAfterCreate interface {
	AfterCreate(context.Context, *CreateGroupResponse, *gorm1.DB) error
}

// Read ...
func (m *GroupsDefaultServer) Read(ctx context.Context, in *ReadGroupRequest) (*ReadGroupResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(GroupsGroupWithBeforeRead); ok {
		var err error
		if db, err = custom.BeforeRead(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadGroup(ctx, &Group{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &ReadGroupResponse{Result: res}
	if custom, ok := interface{}(in).(GroupsGroupWithAfterRead); ok {
		var err error
		if err = custom.AfterRead(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// GroupsGroupWithBeforeRead called before DefaultReadGroup in the default Read handler
type GroupsGroupWithBeforeRead interface {
	BeforeRead(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// GroupsGroupWithAfterRead called before DefaultReadGroup in the default Read handler
type GroupsGroupWithAfterRead interface {
	AfterRead(context.Context, *ReadGroupResponse, *gorm1.DB) error
}

// Update ...
func (m *GroupsDefaultServer) Update(ctx context.Context, in *UpdateGroupRequest) (*UpdateGroupResponse, error) {
	var err error
	var res *Group
	db := m.DB
	if custom, ok := interface{}(in).(GroupsGroupWithBeforeUpdate); ok {
		var err error
		if db, err = custom.BeforeUpdate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err = DefaultStrictUpdateGroup(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &UpdateGroupResponse{Result: res}
	if custom, ok := interface{}(in).(GroupsGroupWithAfterUpdate); ok {
		var err error
		if err = custom.AfterUpdate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// GroupsGroupWithBeforeUpdate called before DefaultUpdateGroup in the default Update handler
type GroupsGroupWithBeforeUpdate interface {
	BeforeUpdate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// GroupsGroupWithAfterUpdate called before DefaultUpdateGroup in the default Update handler
type GroupsGroupWithAfterUpdate interface {
	AfterUpdate(context.Context, *UpdateGroupResponse, *gorm1.DB) error
}

// Delete ...
func (m *GroupsDefaultServer) Delete(ctx context.Context, in *DeleteGroupRequest) (*DeleteGroupResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(GroupsGroupWithBeforeDelete); ok {
		var err error
		if db, err = custom.BeforeDelete(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteGroup(ctx, &Group{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteGroupResponse{}
	if custom, ok := interface{}(in).(GroupsGroupWithAfterDelete); ok {
		var err error
		if err = custom.AfterDelete(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// GroupsGroupWithBeforeDelete called before DefaultDeleteGroup in the default Delete handler
type GroupsGroupWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// GroupsGroupWithAfterDelete called before DefaultDeleteGroup in the default Delete handler
type GroupsGroupWithAfterDelete interface {
	AfterDelete(context.Context, *DeleteGroupResponse, *gorm1.DB) error
}

// List ...
func (m *GroupsDefaultServer) List(ctx context.Context, in *ListGroupRequest) (*ListGroupsResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(GroupsGroupWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultListGroup(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ListGroupsResponse{Results: res}
	if custom, ok := interface{}(in).(GroupsGroupWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// GroupsGroupWithBeforeList called before DefaultListGroup in the default List handler
type GroupsGroupWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// GroupsGroupWithAfterList called before DefaultListGroup in the default List handler
type GroupsGroupWithAfterList interface {
	AfterList(context.Context, *ListGroupsResponse, *gorm1.DB) error
}
type ContactsDefaultServer struct {
	DB *gorm1.DB
}

// Create ...
func (m *ContactsDefaultServer) Create(ctx context.Context, in *CreateContactRequest) (*CreateContactResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ContactsContactWithBeforeCreate); ok {
		var err error
		if db, err = custom.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateContact(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateContactResponse{Result: res}
	if custom, ok := interface{}(in).(ContactsContactWithAfterCreate); ok {
		var err error
		if err = custom.AfterCreate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ContactsContactWithBeforeCreate called before DefaultCreateContact in the default Create handler
type ContactsContactWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ContactsContactWithAfterCreate called before DefaultCreateContact in the default Create handler
type ContactsContactWithAfterCreate interface {
	AfterCreate(context.Context, *CreateContactResponse, *gorm1.DB) error
}

// Read ...
func (m *ContactsDefaultServer) Read(ctx context.Context, in *ReadContactRequest) (*ReadContactResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ContactsContactWithBeforeRead); ok {
		var err error
		if db, err = custom.BeforeRead(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadContact(ctx, &Contact{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &ReadContactResponse{Result: res}
	if custom, ok := interface{}(in).(ContactsContactWithAfterRead); ok {
		var err error
		if err = custom.AfterRead(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ContactsContactWithBeforeRead called before DefaultReadContact in the default Read handler
type ContactsContactWithBeforeRead interface {
	BeforeRead(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ContactsContactWithAfterRead called before DefaultReadContact in the default Read handler
type ContactsContactWithAfterRead interface {
	AfterRead(context.Context, *ReadContactResponse, *gorm1.DB) error
}

// Update ...
func (m *ContactsDefaultServer) Update(ctx context.Context, in *UpdateContactRequest) (*UpdateContactResponse, error) {
	var err error
	var res *Contact
	db := m.DB
	if custom, ok := interface{}(in).(ContactsContactWithBeforeUpdate); ok {
		var err error
		if db, err = custom.BeforeUpdate(ctx, db); err != nil {
			return nil, err
		}
	}
	if in.GetFields() == nil {
		res, err = DefaultStrictUpdateContact(ctx, in.GetPayload(), db)
	} else {
		res, err = DefaultPatchContact(ctx, in.GetPayload(), in.GetFields(), db)
	}
	if err != nil {
		return nil, err
	}
	out := &UpdateContactResponse{Result: res}
	if custom, ok := interface{}(in).(ContactsContactWithAfterUpdate); ok {
		var err error
		if err = custom.AfterUpdate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ContactsContactWithBeforeUpdate called before DefaultUpdateContact in the default Update handler
type ContactsContactWithBeforeUpdate interface {
	BeforeUpdate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ContactsContactWithAfterUpdate called before DefaultUpdateContact in the default Update handler
type ContactsContactWithAfterUpdate interface {
	AfterUpdate(context.Context, *UpdateContactResponse, *gorm1.DB) error
}

// Delete ...
func (m *ContactsDefaultServer) Delete(ctx context.Context, in *DeleteContactRequest) (*DeleteContactResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ContactsContactWithBeforeDelete); ok {
		var err error
		if db, err = custom.BeforeDelete(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteContact(ctx, &Contact{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteContactResponse{}
	if custom, ok := interface{}(in).(ContactsContactWithAfterDelete); ok {
		var err error
		if err = custom.AfterDelete(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ContactsContactWithBeforeDelete called before DefaultDeleteContact in the default Delete handler
type ContactsContactWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ContactsContactWithAfterDelete called before DefaultDeleteContact in the default Delete handler
type ContactsContactWithAfterDelete interface {
	AfterDelete(context.Context, *DeleteContactResponse, *gorm1.DB) error
}

// List ...
func (m *ContactsDefaultServer) List(ctx context.Context, in *ListContactRequest) (*ListContactsResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ContactsContactWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultListContact(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ListContactsResponse{Results: res}
	if custom, ok := interface{}(in).(ContactsContactWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ContactsContactWithBeforeList called before DefaultListContact in the default List handler
type ContactsContactWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ContactsContactWithAfterList called before DefaultListContact in the default List handler
type ContactsContactWithAfterList interface {
	AfterList(context.Context, *ListContactsResponse, *gorm1.DB) error
}

// SendSMS ...
func (m *ContactsDefaultServer) SendSMS(ctx context.Context, in *SMSRequest) (*SMSResponse, error) {
	return &SMSResponse{}, nil
}
