// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pkg/pb/contacts.proto

/*
Package pb is a generated protocol buffer package.

It is generated from these files:
	pkg/pb/contacts.proto

It has these top-level messages:
	Profile
	CreateProfileRequest
	CreateProfileResponse
	ReadProfileRequest
	ReadProfileResponse
	UpdateProfileRequest
	UpdateProfileResponse
	DeleteProfileRequest
	ListProfileRequest
	ListProfilesResponse
	Group
	CreateGroupRequest
	CreateGroupResponse
	ReadGroupRequest
	ReadGroupResponse
	UpdateGroupRequest
	UpdateGroupResponse
	DeleteGroupRequest
	ListGroupRequest
	ListGroupsResponse
	Contact
	Email
	Address
	CreateContactRequest
	CreateContactResponse
	ReadContactRequest
	ReadContactResponse
	UpdateContactRequest
	UpdateContactResponse
	DeleteContactRequest
	ListContactsResponse
	SMSRequest
	ListContactRequest
*/
package pb

import context "context"
import errors "errors"

import auth1 "github.com/infobloxopen/atlas-app-toolkit/auth"
import field_mask1 "google.golang.org/genproto/protobuf/field_mask"
import gateway1 "github.com/infobloxopen/atlas-app-toolkit/gateway"
import gorm1 "github.com/jinzhu/gorm"
import gorm2 "github.com/infobloxopen/atlas-app-toolkit/gorm"
import postgres1 "github.com/jinzhu/gorm/dialects/postgres"
import query1 "github.com/infobloxopen/atlas-app-toolkit/query"
import resource1 "github.com/infobloxopen/atlas-app-toolkit/gorm/resource"
import types1 "github.com/infobloxopen/protoc-gen-gorm/types"

import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/ptypes/empty"
import _ "google.golang.org/genproto/protobuf/field_mask"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import _ "github.com/lyft/protoc-gen-validate/validate"
import _ "github.com/grpc-ecosystem/grpc-gateway/protoc-gen-swagger/options"
import _ "github.com/infobloxopen/atlas-app-toolkit/query"
import _ "github.com/infobloxopen/atlas-app-toolkit/rpc/resource"

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf
var _ = math.Inf

type ProfileORM struct {
	AccountID string
	Contacts  []*ContactORM `gorm:"foreignkey:ProfileId;association_foreignkey:Id"`
	Groups    []*GroupORM   `gorm:"foreignkey:ProfileId;association_foreignkey:Id"`
	Id        int64         `gorm:"type:serial;primary_key"`
	Name      string
	Notes     string
}

// TableName overrides the default tablename generated by GORM
func (ProfileORM) TableName() string {
	return "profiles"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Profile) ToORM(ctx context.Context) (ProfileORM, error) {
	to := ProfileORM{}
	var err error
	if prehook, ok := interface{}(m).(ProfileWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.DecodeInt64(&Profile{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Notes = m.Notes
	for _, v := range m.Contacts {
		if v != nil {
			if tempContacts, cErr := v.ToORM(ctx); cErr == nil {
				to.Contacts = append(to.Contacts, &tempContacts)
			} else {
				return to, cErr
			}
		} else {
			to.Contacts = append(to.Contacts, nil)
		}
	}
	for _, v := range m.Groups {
		if v != nil {
			if tempGroups, cErr := v.ToORM(ctx); cErr == nil {
				to.Groups = append(to.Groups, &tempGroups)
			} else {
				return to, cErr
			}
		} else {
			to.Groups = append(to.Groups, nil)
		}
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(ProfileWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ProfileORM) ToPB(ctx context.Context) (Profile, error) {
	to := Profile{}
	var err error
	if prehook, ok := interface{}(m).(ProfileWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&Profile{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Notes = m.Notes
	for _, v := range m.Contacts {
		if v != nil {
			if tempContacts, cErr := v.ToPB(ctx); cErr == nil {
				to.Contacts = append(to.Contacts, &tempContacts)
			} else {
				return to, cErr
			}
		} else {
			to.Contacts = append(to.Contacts, nil)
		}
	}
	for _, v := range m.Groups {
		if v != nil {
			if tempGroups, cErr := v.ToPB(ctx); cErr == nil {
				to.Groups = append(to.Groups, &tempGroups)
			} else {
				return to, cErr
			}
		} else {
			to.Groups = append(to.Groups, nil)
		}
	}
	if posthook, ok := interface{}(m).(ProfileWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Profile the arg will be the target, the caller the one being converted from

// ProfileBeforeToORM called before default ToORM code
type ProfileWithBeforeToORM interface {
	BeforeToORM(context.Context, *ProfileORM) error
}

// ProfileAfterToORM called after default ToORM code
type ProfileWithAfterToORM interface {
	AfterToORM(context.Context, *ProfileORM) error
}

// ProfileBeforeToPB called before default ToPB code
type ProfileWithBeforeToPB interface {
	BeforeToPB(context.Context, *Profile) error
}

// ProfileAfterToPB called after default ToPB code
type ProfileWithAfterToPB interface {
	AfterToPB(context.Context, *Profile) error
}

type GroupORM struct {
	AccountID string
	Contacts  []*ContactORM `gorm:"foreignkey:Id;association_foreignkey:Id;many2many:group_contacts;jointable_foreignkey:group_id;association_jointable_foreignkey:contact_id"`
	Id        int64         `gorm:"type:serial;primary_key"`
	Name      string
	Notes     string
	ProfileId *int64
}

// TableName overrides the default tablename generated by GORM
func (GroupORM) TableName() string {
	return "groups"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Group) ToORM(ctx context.Context) (GroupORM, error) {
	to := GroupORM{}
	var err error
	if prehook, ok := interface{}(m).(GroupWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.DecodeInt64(&Group{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Notes = m.Notes
	if v, err := resource1.DecodeInt64(&Profile{}, m.ProfileId); err != nil {
		return to, err
	} else {
		to.ProfileId = &v
	}
	for _, v := range m.Contacts {
		if v != nil {
			if tempContacts, cErr := v.ToORM(ctx); cErr == nil {
				to.Contacts = append(to.Contacts, &tempContacts)
			} else {
				return to, cErr
			}
		} else {
			to.Contacts = append(to.Contacts, nil)
		}
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(GroupWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *GroupORM) ToPB(ctx context.Context) (Group, error) {
	to := Group{}
	var err error
	if prehook, ok := interface{}(m).(GroupWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&Group{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Notes = m.Notes
	if m.ProfileId != nil {
		if v, err := resource1.Encode(&Profile{}, *m.ProfileId); err != nil {
			return to, err
		} else {
			to.ProfileId = v
		}
	} else {
		if v, err := resource1.Encode(&Profile{}, nil); err != nil {
			return to, err
		} else {
			to.ProfileId = v
		}
	}
	for _, v := range m.Contacts {
		if v != nil {
			if tempContacts, cErr := v.ToPB(ctx); cErr == nil {
				to.Contacts = append(to.Contacts, &tempContacts)
			} else {
				return to, cErr
			}
		} else {
			to.Contacts = append(to.Contacts, nil)
		}
	}
	if posthook, ok := interface{}(m).(GroupWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Group the arg will be the target, the caller the one being converted from

// GroupBeforeToORM called before default ToORM code
type GroupWithBeforeToORM interface {
	BeforeToORM(context.Context, *GroupORM) error
}

// GroupAfterToORM called after default ToORM code
type GroupWithAfterToORM interface {
	AfterToORM(context.Context, *GroupORM) error
}

// GroupBeforeToPB called before default ToPB code
type GroupWithBeforeToPB interface {
	BeforeToPB(context.Context, *Group) error
}

// GroupAfterToPB called after default ToPB code
type GroupWithAfterToPB interface {
	AfterToPB(context.Context, *Group) error
}

type ContactORM struct {
	AccountID   string
	Emails      []*EmailORM `gorm:"foreignkey:ContactId;association_foreignkey:Id"`
	FirstName   string
	Groups      []*GroupORM `gorm:"foreignkey:Id;association_foreignkey:Id;many2many:group_contacts;jointable_foreignkey:contact_id;association_jointable_foreignkey:group_id"`
	HomeAddress *AddressORM `gorm:"foreignkey:HomeAddressContactId;association_foreignkey:Id"`
	Id          int64       `gorm:"type:serial;primary_key"`
	LastName    string
	MiddleName  string
	Nicknames   *postgres1.Jsonb `gorm:"type:jsonb"`
	Notes       string
	ProfileId   *int64
	WorkAddress *AddressORM `gorm:"foreignkey:WorkAddressContactId;association_foreignkey:Id"`
}

// TableName overrides the default tablename generated by GORM
func (ContactORM) TableName() string {
	return "contacts"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Contact) ToORM(ctx context.Context) (ContactORM, error) {
	to := ContactORM{}
	var err error
	if prehook, ok := interface{}(m).(ContactWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.DecodeInt64(&Contact{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.FirstName = m.FirstName
	to.MiddleName = m.MiddleName
	to.LastName = m.LastName
	to.Notes = m.Notes
	for _, v := range m.Emails {
		if v != nil {
			if tempEmails, cErr := v.ToORM(ctx); cErr == nil {
				to.Emails = append(to.Emails, &tempEmails)
			} else {
				return to, cErr
			}
		} else {
			to.Emails = append(to.Emails, nil)
		}
	}
	if m.HomeAddress != nil {
		tempHomeAddress, err := m.HomeAddress.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.HomeAddress = &tempHomeAddress
	}
	if m.WorkAddress != nil {
		tempWorkAddress, err := m.WorkAddress.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.WorkAddress = &tempWorkAddress
	}
	if v, err := resource1.DecodeInt64(&Profile{}, m.ProfileId); err != nil {
		return to, err
	} else {
		to.ProfileId = &v
	}
	for _, v := range m.Groups {
		if v != nil {
			if tempGroups, cErr := v.ToORM(ctx); cErr == nil {
				to.Groups = append(to.Groups, &tempGroups)
			} else {
				return to, cErr
			}
		} else {
			to.Groups = append(to.Groups, nil)
		}
	}
	if m.Nicknames != nil {
		to.Nicknames = &postgres1.Jsonb{[]byte(m.Nicknames.Value)}
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(ContactWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ContactORM) ToPB(ctx context.Context) (Contact, error) {
	to := Contact{}
	var err error
	if prehook, ok := interface{}(m).(ContactWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&Contact{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.FirstName = m.FirstName
	to.MiddleName = m.MiddleName
	to.LastName = m.LastName
	to.Notes = m.Notes
	for _, v := range m.Emails {
		if v != nil {
			if tempEmails, cErr := v.ToPB(ctx); cErr == nil {
				to.Emails = append(to.Emails, &tempEmails)
			} else {
				return to, cErr
			}
		} else {
			to.Emails = append(to.Emails, nil)
		}
	}
	if m.HomeAddress != nil {
		tempHomeAddress, err := m.HomeAddress.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.HomeAddress = &tempHomeAddress
	}
	if m.WorkAddress != nil {
		tempWorkAddress, err := m.WorkAddress.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.WorkAddress = &tempWorkAddress
	}
	if m.ProfileId != nil {
		if v, err := resource1.Encode(&Profile{}, *m.ProfileId); err != nil {
			return to, err
		} else {
			to.ProfileId = v
		}
	} else {
		if v, err := resource1.Encode(&Profile{}, nil); err != nil {
			return to, err
		} else {
			to.ProfileId = v
		}
	}
	for _, v := range m.Groups {
		if v != nil {
			if tempGroups, cErr := v.ToPB(ctx); cErr == nil {
				to.Groups = append(to.Groups, &tempGroups)
			} else {
				return to, cErr
			}
		} else {
			to.Groups = append(to.Groups, nil)
		}
	}
	if m.Nicknames != nil {
		to.Nicknames = &types1.JSONValue{Value: string(m.Nicknames.RawMessage)}
	}
	if posthook, ok := interface{}(m).(ContactWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Contact the arg will be the target, the caller the one being converted from

// ContactBeforeToORM called before default ToORM code
type ContactWithBeforeToORM interface {
	BeforeToORM(context.Context, *ContactORM) error
}

// ContactAfterToORM called after default ToORM code
type ContactWithAfterToORM interface {
	AfterToORM(context.Context, *ContactORM) error
}

// ContactBeforeToPB called before default ToPB code
type ContactWithBeforeToPB interface {
	BeforeToPB(context.Context, *Contact) error
}

// ContactAfterToPB called after default ToPB code
type ContactWithAfterToPB interface {
	AfterToPB(context.Context, *Contact) error
}

type EmailORM struct {
	AccountID string
	Address   string `gorm:"unique"`
	ContactId *int64
	Id        uint64
	IsPrimary bool
}

// TableName overrides the default tablename generated by GORM
func (EmailORM) TableName() string {
	return "emails"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Email) ToORM(ctx context.Context) (EmailORM, error) {
	to := EmailORM{}
	var err error
	if prehook, ok := interface{}(m).(EmailWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Address = m.Address
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(EmailWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *EmailORM) ToPB(ctx context.Context) (Email, error) {
	to := Email{}
	var err error
	if prehook, ok := interface{}(m).(EmailWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Address = m.Address
	if posthook, ok := interface{}(m).(EmailWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Email the arg will be the target, the caller the one being converted from

// EmailBeforeToORM called before default ToORM code
type EmailWithBeforeToORM interface {
	BeforeToORM(context.Context, *EmailORM) error
}

// EmailAfterToORM called after default ToORM code
type EmailWithAfterToORM interface {
	AfterToORM(context.Context, *EmailORM) error
}

// EmailBeforeToPB called before default ToPB code
type EmailWithBeforeToPB interface {
	BeforeToPB(context.Context, *Email) error
}

// EmailAfterToPB called after default ToPB code
type EmailWithAfterToPB interface {
	AfterToPB(context.Context, *Email) error
}

type AddressORM struct {
	AccountID            string
	Address              string
	City                 string
	Country              string
	HomeAddressContactId *int64
	State                string
	WorkAddressContactId *int64
	Zip                  string
}

// TableName overrides the default tablename generated by GORM
func (AddressORM) TableName() string {
	return "addresses"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Address) ToORM(ctx context.Context) (AddressORM, error) {
	to := AddressORM{}
	var err error
	if prehook, ok := interface{}(m).(AddressWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Address = m.Address
	to.City = m.City
	to.State = m.State
	to.Zip = m.Zip
	to.Country = m.Country
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(AddressWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *AddressORM) ToPB(ctx context.Context) (Address, error) {
	to := Address{}
	var err error
	if prehook, ok := interface{}(m).(AddressWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Address = m.Address
	to.City = m.City
	to.State = m.State
	to.Zip = m.Zip
	to.Country = m.Country
	if posthook, ok := interface{}(m).(AddressWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Address the arg will be the target, the caller the one being converted from

// AddressBeforeToORM called before default ToORM code
type AddressWithBeforeToORM interface {
	BeforeToORM(context.Context, *AddressORM) error
}

// AddressAfterToORM called after default ToORM code
type AddressWithAfterToORM interface {
	AfterToORM(context.Context, *AddressORM) error
}

// AddressBeforeToPB called before default ToPB code
type AddressWithBeforeToPB interface {
	BeforeToPB(context.Context, *Address) error
}

// AddressAfterToPB called after default ToPB code
type AddressWithAfterToPB interface {
	AfterToPB(context.Context, *Address) error
}

// DefaultCreateProfile executes a basic gorm create call
func DefaultCreateProfile(ctx context.Context, in *Profile, db *gorm1.DB) (*Profile, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultCreateProfile")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

// DefaultReadProfile executes a basic gorm read call
func DefaultReadProfile(ctx context.Context, in *Profile, db *gorm1.DB) (*Profile, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultReadProfile")
	}
	db = db.Set("gorm:auto_preload", true)
	ormParams, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	ormResponse := ProfileORM{}
	if err = db.Where(&ormParams).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

// DefaultUpdateProfile executes a basic gorm update call
func DefaultUpdateProfile(ctx context.Context, in *Profile, db *gorm1.DB) (*Profile, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultUpdateProfile")
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	if exists, err := DefaultReadProfile(ctx, &Profile{Id: in.GetId()}, db); err != nil {
		return nil, err
	} else if exists == nil {
		return nil, errors.New("Profile not found")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	ormObj.AccountID = accountID
	db = db.Where(&ProfileORM{AccountID: accountID})
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

func DefaultDeleteProfile(ctx context.Context, in *Profile, db *gorm1.DB) error {
	if in == nil {
		return errors.New("Nil argument to DefaultDeleteProfile")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.New("A non-zero ID value is required for a delete call")
	}
	err = db.Where(&ormObj).Delete(&ProfileORM{}).Error
	return err
}

// DefaultStrictUpdateProfile clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateProfile(ctx context.Context, in *Profile, db *gorm1.DB) (*Profile, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateProfile")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	count := 1
	err = db.Model(&ormObj).Where("id=?", ormObj.Id).Count(&count).Error
	if err != nil {
		return nil, err
	}
	filterContacts := ContactORM{}
	if ormObj.Id == 0 {
		return nil, errors.New("Can't do overwriting update with no Id value for ProfileORM")
	}
	filterContacts.ProfileId = new(int64)
	*filterContacts.ProfileId = ormObj.Id
	filterContacts.AccountID = ormObj.AccountID
	if err = db.Where(filterContacts).Delete(ContactORM{}).Error; err != nil {
		return nil, err
	}
	filterGroups := GroupORM{}
	if ormObj.Id == 0 {
		return nil, errors.New("Can't do overwriting update with no Id value for ProfileORM")
	}
	filterGroups.ProfileId = new(int64)
	*filterGroups.ProfileId = ormObj.Id
	filterGroups.AccountID = ormObj.AccountID
	if err = db.Where(filterGroups).Delete(GroupORM{}).Error; err != nil {
		return nil, err
	}
	db = db.Where(&ProfileORM{AccountID: ormObj.AccountID})
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	if count == 0 {
		err = gateway1.SetCreated(ctx, "")
	}
	return &pbResponse, err
}

// DefaultPatchProfile executes a basic gorm update call with patch behavior
func DefaultPatchProfile(ctx context.Context, in *Profile, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Profile, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultPatchProfile")
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	ormParams, err := (&Profile{Id: in.GetId()}).ToORM(ctx)
	if err != nil {
		return nil, err
	}
	db = db.Where(&ProfileORM{AccountID: accountID})
	ormObj := ProfileORM{}
	if err := db.Where(&ormParams).First(&ormObj).Error; err != nil {
		return nil, err
	}
	pbObj, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	if _, err := DefaultApplyFieldMaskProfile(ctx, &pbObj, &ormObj, in, updateMask, db); err != nil {
		return nil, err
	}
	ormObj, err = pbObj.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	db = db.Where(&ProfileORM{AccountID: accountID})
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	pbObj, err = ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbObj, err
}

// DefaultApplyFieldMaskProfile patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskProfile(ctx context.Context, patchee *Profile, ormObj *ProfileORM, patcher *Profile, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Profile, error) {
	var err error
	for _, f := range updateMask.GetPaths() {
		if f == "Id" {
			patchee.Id = patcher.Id
		}
		if f == "Name" {
			patchee.Name = patcher.Name
		}
		if f == "Notes" {
			patchee.Notes = patcher.Notes
		}
		if f == "Contacts" {
			patchee.Contacts = patcher.Contacts
			filterContacts := ContactORM{}
			if ormObj.Id == 0 {
				return nil, errors.New("Can't do overwriting update with no Id value for ProfileORM")
			}
			filterContacts.ProfileId = new(int64)
			*filterContacts.ProfileId = ormObj.Id
			filterContacts.AccountID = ormObj.AccountID
			if err = db.Where(filterContacts).Delete(ContactORM{}).Error; err != nil {
				return nil, err
			}
		}
		if f == "Groups" {
			patchee.Groups = patcher.Groups
			filterGroups := GroupORM{}
			if ormObj.Id == 0 {
				return nil, errors.New("Can't do overwriting update with no Id value for ProfileORM")
			}
			filterGroups.ProfileId = new(int64)
			*filterGroups.ProfileId = ormObj.Id
			filterGroups.AccountID = ormObj.AccountID
			if err = db.Where(filterGroups).Delete(GroupORM{}).Error; err != nil {
				return nil, err
			}
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// getCollectionOperators takes collection operator values from corresponding message fields
func getCollectionOperators(in interface{}) (*query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection, error) {
	f := &query1.Filtering{}
	err := gateway1.GetCollectionOp(in, f)
	if err != nil {
		return nil, nil, nil, nil, err
	}
	s := &query1.Sorting{}
	err = gateway1.GetCollectionOp(in, s)
	if err != nil {
		return nil, nil, nil, nil, err
	}
	p := &query1.Pagination{}
	err = gateway1.GetCollectionOp(in, p)
	if err != nil {
		return nil, nil, nil, nil, err
	}
	fs := &query1.FieldSelection{}
	err = gateway1.GetCollectionOp(in, fs)
	if err != nil {
		return nil, nil, nil, nil, err
	}
	return f, s, p, fs, nil
}

// DefaultListProfile executes a gorm list call
func DefaultListProfile(ctx context.Context, db *gorm1.DB, req interface{}) ([]*Profile, error) {
	ormResponse := []ProfileORM{}
	f, s, p, fs, err := getCollectionOperators(req)
	if err != nil {
		return nil, err
	}
	db, err = gorm2.ApplyCollectionOperators(db, &ProfileORM{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if fs.GetFields() == nil {
		db = db.Set("gorm:auto_preload", true)
	}
	in := Profile{}
	ormParams, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	db = db.Where(&ormParams)
	db = db.Order("id")
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	pbResponse := []*Profile{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

// DefaultCreateGroup executes a basic gorm create call
func DefaultCreateGroup(ctx context.Context, in *Group, db *gorm1.DB) (*Group, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultCreateGroup")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

// DefaultReadGroup executes a basic gorm read call
func DefaultReadGroup(ctx context.Context, in *Group, db *gorm1.DB) (*Group, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultReadGroup")
	}
	db = db.Set("gorm:auto_preload", true)
	ormParams, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	ormResponse := GroupORM{}
	if err = db.Where(&ormParams).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

// DefaultUpdateGroup executes a basic gorm update call
func DefaultUpdateGroup(ctx context.Context, in *Group, db *gorm1.DB) (*Group, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultUpdateGroup")
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	if exists, err := DefaultReadGroup(ctx, &Group{Id: in.GetId()}, db); err != nil {
		return nil, err
	} else if exists == nil {
		return nil, errors.New("Group not found")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	ormObj.AccountID = accountID
	db = db.Where(&GroupORM{AccountID: accountID})
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

func DefaultDeleteGroup(ctx context.Context, in *Group, db *gorm1.DB) error {
	if in == nil {
		return errors.New("Nil argument to DefaultDeleteGroup")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.New("A non-zero ID value is required for a delete call")
	}
	err = db.Where(&ormObj).Delete(&GroupORM{}).Error
	return err
}

// DefaultStrictUpdateGroup clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateGroup(ctx context.Context, in *Group, db *gorm1.DB) (*Group, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateGroup")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	count := 1
	err = db.Model(&ormObj).Where("id=?", ormObj.Id).Count(&count).Error
	if err != nil {
		return nil, err
	}
	db = db.Where(&GroupORM{AccountID: ormObj.AccountID})
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	if count == 0 {
		err = gateway1.SetCreated(ctx, "")
	}
	return &pbResponse, err
}

// DefaultPatchGroup executes a basic gorm update call with patch behavior
func DefaultPatchGroup(ctx context.Context, in *Group, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Group, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultPatchGroup")
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	ormParams, err := (&Group{Id: in.GetId()}).ToORM(ctx)
	if err != nil {
		return nil, err
	}
	db = db.Where(&GroupORM{AccountID: accountID})
	ormObj := GroupORM{}
	if err := db.Where(&ormParams).First(&ormObj).Error; err != nil {
		return nil, err
	}
	pbObj, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	if _, err := DefaultApplyFieldMaskGroup(ctx, &pbObj, &ormObj, in, updateMask, db); err != nil {
		return nil, err
	}
	ormObj, err = pbObj.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	db = db.Where(&GroupORM{AccountID: accountID})
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	pbObj, err = ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbObj, err
}

// DefaultApplyFieldMaskGroup patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskGroup(ctx context.Context, patchee *Group, ormObj *GroupORM, patcher *Group, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Group, error) {
	var err error
	for _, f := range updateMask.GetPaths() {
		if f == "Id" {
			patchee.Id = patcher.Id
		}
		if f == "Name" {
			patchee.Name = patcher.Name
		}
		if f == "Notes" {
			patchee.Notes = patcher.Notes
		}
		if f == "ProfileId" {
			patchee.ProfileId = patcher.ProfileId
		}
		if f == "Contacts" {
			patchee.Contacts = patcher.Contacts
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListGroup executes a gorm list call
func DefaultListGroup(ctx context.Context, db *gorm1.DB, req interface{}) ([]*Group, error) {
	ormResponse := []GroupORM{}
	f, s, p, fs, err := getCollectionOperators(req)
	if err != nil {
		return nil, err
	}
	db, err = gorm2.ApplyCollectionOperators(db, &GroupORM{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if fs.GetFields() == nil {
		db = db.Set("gorm:auto_preload", true)
	}
	in := Group{}
	ormParams, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	db = db.Where(&ormParams)
	db = db.Order("id")
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	pbResponse := []*Group{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

// DefaultCreateContact executes a basic gorm create call
func DefaultCreateContact(ctx context.Context, in *Contact, db *gorm1.DB) (*Contact, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultCreateContact")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

// DefaultReadContact executes a basic gorm read call
func DefaultReadContact(ctx context.Context, in *Contact, db *gorm1.DB) (*Contact, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultReadContact")
	}
	db = db.Set("gorm:auto_preload", true)
	ormParams, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	ormResponse := ContactORM{}
	if err = db.Where(&ormParams).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

// DefaultUpdateContact executes a basic gorm update call
func DefaultUpdateContact(ctx context.Context, in *Contact, db *gorm1.DB) (*Contact, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultUpdateContact")
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	if exists, err := DefaultReadContact(ctx, &Contact{Id: in.GetId()}, db); err != nil {
		return nil, err
	} else if exists == nil {
		return nil, errors.New("Contact not found")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	ormObj.AccountID = accountID
	db = db.Where(&ContactORM{AccountID: accountID})
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

func DefaultDeleteContact(ctx context.Context, in *Contact, db *gorm1.DB) error {
	if in == nil {
		return errors.New("Nil argument to DefaultDeleteContact")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.New("A non-zero ID value is required for a delete call")
	}
	err = db.Where(&ormObj).Delete(&ContactORM{}).Error
	return err
}

// DefaultStrictUpdateContact clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateContact(ctx context.Context, in *Contact, db *gorm1.DB) (*Contact, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateContact")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	count := 1
	err = db.Model(&ormObj).Where("id=?", ormObj.Id).Count(&count).Error
	if err != nil {
		return nil, err
	}
	filterEmails := EmailORM{}
	if ormObj.Id == 0 {
		return nil, errors.New("Can't do overwriting update with no Id value for ContactORM")
	}
	filterEmails.ContactId = new(int64)
	*filterEmails.ContactId = ormObj.Id
	filterEmails.AccountID = ormObj.AccountID
	if err = db.Where(filterEmails).Delete(EmailORM{}).Error; err != nil {
		return nil, err
	}
	filterHomeAddress := AddressORM{}
	if ormObj.Id == 0 {
		return nil, errors.New("Can't do overwriting update with no Id value for ContactORM")
	}
	filterHomeAddress.HomeAddressContactId = new(int64)
	*filterHomeAddress.HomeAddressContactId = ormObj.Id
	filterHomeAddress.AccountID = ormObj.AccountID
	if err = db.Where(filterHomeAddress).Delete(AddressORM{}).Error; err != nil {
		return nil, err
	}
	filterWorkAddress := AddressORM{}
	if ormObj.Id == 0 {
		return nil, errors.New("Can't do overwriting update with no Id value for ContactORM")
	}
	filterWorkAddress.WorkAddressContactId = new(int64)
	*filterWorkAddress.WorkAddressContactId = ormObj.Id
	filterWorkAddress.AccountID = ormObj.AccountID
	if err = db.Where(filterWorkAddress).Delete(AddressORM{}).Error; err != nil {
		return nil, err
	}
	db = db.Where(&ContactORM{AccountID: ormObj.AccountID})
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	if count == 0 {
		err = gateway1.SetCreated(ctx, "")
	}
	return &pbResponse, err
}

// DefaultPatchContact executes a basic gorm update call with patch behavior
func DefaultPatchContact(ctx context.Context, in *Contact, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Contact, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultPatchContact")
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	ormParams, err := (&Contact{Id: in.GetId()}).ToORM(ctx)
	if err != nil {
		return nil, err
	}
	db = db.Where(&ContactORM{AccountID: accountID})
	ormObj := ContactORM{}
	if err := db.Where(&ormParams).First(&ormObj).Error; err != nil {
		return nil, err
	}
	pbObj, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	if _, err := DefaultApplyFieldMaskContact(ctx, &pbObj, &ormObj, in, updateMask, db); err != nil {
		return nil, err
	}
	ormObj, err = pbObj.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	db = db.Where(&ContactORM{AccountID: accountID})
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	pbObj, err = ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbObj, err
}

// DefaultApplyFieldMaskContact patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskContact(ctx context.Context, patchee *Contact, ormObj *ContactORM, patcher *Contact, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Contact, error) {
	var err error
	for _, f := range updateMask.GetPaths() {
		if f == "Id" {
			patchee.Id = patcher.Id
		}
		if f == "FirstName" {
			patchee.FirstName = patcher.FirstName
		}
		if f == "MiddleName" {
			patchee.MiddleName = patcher.MiddleName
		}
		if f == "LastName" {
			patchee.LastName = patcher.LastName
		}
		if f == "PrimaryEmail" {
			patchee.PrimaryEmail = patcher.PrimaryEmail
		}
		if f == "Notes" {
			patchee.Notes = patcher.Notes
		}
		if f == "Emails" {
			patchee.Emails = patcher.Emails
			filterEmails := EmailORM{}
			if ormObj.Id == 0 {
				return nil, errors.New("Can't do overwriting update with no Id value for ContactORM")
			}
			filterEmails.ContactId = new(int64)
			*filterEmails.ContactId = ormObj.Id
			filterEmails.AccountID = ormObj.AccountID
			if err = db.Where(filterEmails).Delete(EmailORM{}).Error; err != nil {
				return nil, err
			}
		}
		if f == "HomeAddress" {
			patchee.HomeAddress = patcher.HomeAddress
			filterHomeAddress := AddressORM{}
			if ormObj.Id == 0 {
				return nil, errors.New("Can't do overwriting update with no Id value for ContactORM")
			}
			filterHomeAddress.HomeAddressContactId = new(int64)
			*filterHomeAddress.HomeAddressContactId = ormObj.Id
			filterHomeAddress.AccountID = ormObj.AccountID
			if err = db.Where(filterHomeAddress).Delete(AddressORM{}).Error; err != nil {
				return nil, err
			}
		}
		if f == "WorkAddress" {
			patchee.WorkAddress = patcher.WorkAddress
			filterWorkAddress := AddressORM{}
			if ormObj.Id == 0 {
				return nil, errors.New("Can't do overwriting update with no Id value for ContactORM")
			}
			filterWorkAddress.WorkAddressContactId = new(int64)
			*filterWorkAddress.WorkAddressContactId = ormObj.Id
			filterWorkAddress.AccountID = ormObj.AccountID
			if err = db.Where(filterWorkAddress).Delete(AddressORM{}).Error; err != nil {
				return nil, err
			}
		}
		if f == "ProfileId" {
			patchee.ProfileId = patcher.ProfileId
		}
		if f == "Groups" {
			patchee.Groups = patcher.Groups
		}
		if f == "Nicknames" {
			patchee.Nicknames = patcher.Nicknames
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListContact executes a gorm list call
func DefaultListContact(ctx context.Context, db *gorm1.DB, req interface{}) ([]*Contact, error) {
	ormResponse := []ContactORM{}
	f, s, p, fs, err := getCollectionOperators(req)
	if err != nil {
		return nil, err
	}
	db, err = gorm2.ApplyCollectionOperators(db, &ContactORM{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if fs.GetFields() == nil {
		db = db.Set("gorm:auto_preload", true)
	}
	in := Contact{}
	ormParams, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	db = db.Where(&ormParams)
	db = db.Order("id")
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	pbResponse := []*Contact{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

// DefaultCreateEmail executes a basic gorm create call
func DefaultCreateEmail(ctx context.Context, in *Email, db *gorm1.DB) (*Email, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultCreateEmail")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

// DefaultReadEmail executes a basic gorm read call
func DefaultReadEmail(ctx context.Context, in *Email, db *gorm1.DB) (*Email, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultReadEmail")
	}
	db = db.Set("gorm:auto_preload", true)
	ormParams, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	ormResponse := EmailORM{}
	if err = db.Where(&ormParams).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

// DefaultUpdateEmail executes a basic gorm update call
func DefaultUpdateEmail(ctx context.Context, in *Email, db *gorm1.DB) (*Email, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultUpdateEmail")
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	if exists, err := DefaultReadEmail(ctx, &Email{Id: in.GetId()}, db); err != nil {
		return nil, err
	} else if exists == nil {
		return nil, errors.New("Email not found")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	ormObj.AccountID = accountID
	db = db.Where(&EmailORM{AccountID: accountID})
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

func DefaultDeleteEmail(ctx context.Context, in *Email, db *gorm1.DB) error {
	if in == nil {
		return errors.New("Nil argument to DefaultDeleteEmail")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.New("A non-zero ID value is required for a delete call")
	}
	err = db.Where(&ormObj).Delete(&EmailORM{}).Error
	return err
}

// DefaultStrictUpdateEmail clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateEmail(ctx context.Context, in *Email, db *gorm1.DB) (*Email, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateEmail")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	count := 1
	err = db.Model(&ormObj).Where("id=?", ormObj.Id).Count(&count).Error
	if err != nil {
		return nil, err
	}
	db = db.Where(&EmailORM{AccountID: ormObj.AccountID})
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	if count == 0 {
		err = gateway1.SetCreated(ctx, "")
	}
	return &pbResponse, err
}

// DefaultPatchEmail executes a basic gorm update call with patch behavior
func DefaultPatchEmail(ctx context.Context, in *Email, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Email, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultPatchEmail")
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	ormParams, err := (&Email{Id: in.GetId()}).ToORM(ctx)
	if err != nil {
		return nil, err
	}
	db = db.Where(&EmailORM{AccountID: accountID})
	ormObj := EmailORM{}
	if err := db.Where(&ormParams).First(&ormObj).Error; err != nil {
		return nil, err
	}
	pbObj, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	if _, err := DefaultApplyFieldMaskEmail(ctx, &pbObj, &ormObj, in, updateMask, db); err != nil {
		return nil, err
	}
	ormObj, err = pbObj.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	db = db.Where(&EmailORM{AccountID: accountID})
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	pbObj, err = ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbObj, err
}

// DefaultApplyFieldMaskEmail patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskEmail(ctx context.Context, patchee *Email, ormObj *EmailORM, patcher *Email, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Email, error) {
	var err error
	for _, f := range updateMask.GetPaths() {
		if f == "Id" {
			patchee.Id = patcher.Id
		}
		if f == "Address" {
			patchee.Address = patcher.Address
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListEmail executes a gorm list call
func DefaultListEmail(ctx context.Context, db *gorm1.DB, req interface{}) ([]*Email, error) {
	ormResponse := []EmailORM{}
	f, s, p, fs, err := getCollectionOperators(req)
	if err != nil {
		return nil, err
	}
	db, err = gorm2.ApplyCollectionOperators(db, &EmailORM{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if fs.GetFields() == nil {
		db = db.Set("gorm:auto_preload", true)
	}
	in := Email{}
	ormParams, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	db = db.Where(&ormParams)
	db = db.Order("id")
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	pbResponse := []*Email{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

// DefaultCreateAddress executes a basic gorm create call
func DefaultCreateAddress(ctx context.Context, in *Address, db *gorm1.DB) (*Address, error) {
	if in == nil {
		return nil, errors.New("Nil argument to DefaultCreateAddress")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

// DefaultListAddress executes a gorm list call
func DefaultListAddress(ctx context.Context, db *gorm1.DB, req interface{}) ([]*Address, error) {
	ormResponse := []AddressORM{}
	f, s, p, fs, err := getCollectionOperators(req)
	if err != nil {
		return nil, err
	}
	db, err = gorm2.ApplyCollectionOperators(db, &AddressORM{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if fs.GetFields() == nil {
		db = db.Set("gorm:auto_preload", true)
	}
	in := Address{}
	ormParams, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	db = db.Where(&ormParams)
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	pbResponse := []*Address{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ProfilesDefaultServer struct {
	DB *gorm1.DB
}

// Create ...
func (m *ProfilesDefaultServer) Create(ctx context.Context, in *CreateProfileRequest) (*CreateProfileResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ProfilesProfileWithBeforeCreate); ok {
		var err error
		ctx, db, err = custom.BeforeCreate(ctx, in, db)
		if err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateProfile(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	return &CreateProfileResponse{Result: res}, nil
}

// ProfilesProfileWithBeforeCreate called before DefaultCreateProfile in the default Create handler
type ProfilesProfileWithBeforeCreate interface {
	BeforeCreate(context.Context, *CreateProfileRequest, *gorm1.DB) (context.Context, *gorm1.DB, error)
}

// Read ...
func (m *ProfilesDefaultServer) Read(ctx context.Context, in *ReadProfileRequest) (*ReadProfileResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ProfilesProfileWithBeforeRead); ok {
		var err error
		ctx, db, err = custom.BeforeRead(ctx, in, db)
		if err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadProfile(ctx, &Profile{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	return &ReadProfileResponse{Result: res}, nil
}

// ProfilesProfileWithBeforeRead called before DefaultReadProfile in the default Read handler
type ProfilesProfileWithBeforeRead interface {
	BeforeRead(context.Context, *ReadProfileRequest, *gorm1.DB) (context.Context, *gorm1.DB, error)
}

// Update ...
func (m *ProfilesDefaultServer) Update(ctx context.Context, in *UpdateProfileRequest) (*UpdateProfileResponse, error) {
	var err error
	var res *Profile
	db := m.DB
	if custom, ok := interface{}(in).(ProfilesProfileWithBeforeUpdate); ok {
		var err error
		ctx, db, err = custom.BeforeUpdate(ctx, in, db)
		if err != nil {
			return nil, err
		}
	}
	res, err = DefaultStrictUpdateProfile(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	return &UpdateProfileResponse{Result: res}, nil
}

// ProfilesProfileWithBeforeUpdate called before DefaultUpdateProfile in the default Update handler
type ProfilesProfileWithBeforeUpdate interface {
	BeforeUpdate(context.Context, *UpdateProfileRequest, *gorm1.DB) (context.Context, *gorm1.DB, error)
}

// Delete ...
func (m *ProfilesDefaultServer) Delete(ctx context.Context, in *DeleteProfileRequest) (*google_protobuf.Empty, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ProfilesProfileWithBeforeDelete); ok {
		var err error
		ctx, db, err = custom.BeforeDelete(ctx, in, db)
		if err != nil {
			return nil, err
		}
	}
	return &google_protobuf.Empty{}, DefaultDeleteProfile(ctx, &Profile{Id: in.GetId()}, db)
}

// ProfilesProfileWithBeforeDelete called before DefaultDeleteProfile in the default Delete handler
type ProfilesProfileWithBeforeDelete interface {
	BeforeDelete(context.Context, *DeleteProfileRequest, *gorm1.DB) (context.Context, *gorm1.DB, error)
}

// List ...
func (m *ProfilesDefaultServer) List(ctx context.Context, in *ListProfileRequest) (*ListProfilesResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ProfilesProfileWithBeforeList); ok {
		var err error
		ctx, db, err = custom.BeforeList(ctx, in, db)
		if err != nil {
			return nil, err
		}
	}
	res, err := DefaultListProfile(ctx, db, in)
	if err != nil {
		return nil, err
	}
	return &ListProfilesResponse{Results: res}, nil
}

// ProfilesProfileWithBeforeList called before DefaultListProfile in the default List handler
type ProfilesProfileWithBeforeList interface {
	BeforeList(context.Context, *ListProfileRequest, *gorm1.DB) (context.Context, *gorm1.DB, error)
}
type GroupsDefaultServer struct {
	DB *gorm1.DB
}

// Create ...
func (m *GroupsDefaultServer) Create(ctx context.Context, in *CreateGroupRequest) (*CreateGroupResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(GroupsGroupWithBeforeCreate); ok {
		var err error
		ctx, db, err = custom.BeforeCreate(ctx, in, db)
		if err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateGroup(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	return &CreateGroupResponse{Result: res}, nil
}

// GroupsGroupWithBeforeCreate called before DefaultCreateGroup in the default Create handler
type GroupsGroupWithBeforeCreate interface {
	BeforeCreate(context.Context, *CreateGroupRequest, *gorm1.DB) (context.Context, *gorm1.DB, error)
}

// Read ...
func (m *GroupsDefaultServer) Read(ctx context.Context, in *ReadGroupRequest) (*ReadGroupResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(GroupsGroupWithBeforeRead); ok {
		var err error
		ctx, db, err = custom.BeforeRead(ctx, in, db)
		if err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadGroup(ctx, &Group{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	return &ReadGroupResponse{Result: res}, nil
}

// GroupsGroupWithBeforeRead called before DefaultReadGroup in the default Read handler
type GroupsGroupWithBeforeRead interface {
	BeforeRead(context.Context, *ReadGroupRequest, *gorm1.DB) (context.Context, *gorm1.DB, error)
}

// Update ...
func (m *GroupsDefaultServer) Update(ctx context.Context, in *UpdateGroupRequest) (*UpdateGroupResponse, error) {
	var err error
	var res *Group
	db := m.DB
	if custom, ok := interface{}(in).(GroupsGroupWithBeforeUpdate); ok {
		var err error
		ctx, db, err = custom.BeforeUpdate(ctx, in, db)
		if err != nil {
			return nil, err
		}
	}
	res, err = DefaultStrictUpdateGroup(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	return &UpdateGroupResponse{Result: res}, nil
}

// GroupsGroupWithBeforeUpdate called before DefaultUpdateGroup in the default Update handler
type GroupsGroupWithBeforeUpdate interface {
	BeforeUpdate(context.Context, *UpdateGroupRequest, *gorm1.DB) (context.Context, *gorm1.DB, error)
}

// Delete ...
func (m *GroupsDefaultServer) Delete(ctx context.Context, in *DeleteGroupRequest) (*google_protobuf.Empty, error) {
	db := m.DB
	if custom, ok := interface{}(in).(GroupsGroupWithBeforeDelete); ok {
		var err error
		ctx, db, err = custom.BeforeDelete(ctx, in, db)
		if err != nil {
			return nil, err
		}
	}
	return &google_protobuf.Empty{}, DefaultDeleteGroup(ctx, &Group{Id: in.GetId()}, db)
}

// GroupsGroupWithBeforeDelete called before DefaultDeleteGroup in the default Delete handler
type GroupsGroupWithBeforeDelete interface {
	BeforeDelete(context.Context, *DeleteGroupRequest, *gorm1.DB) (context.Context, *gorm1.DB, error)
}

// List ...
func (m *GroupsDefaultServer) List(ctx context.Context, in *ListGroupRequest) (*ListGroupsResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(GroupsGroupWithBeforeList); ok {
		var err error
		ctx, db, err = custom.BeforeList(ctx, in, db)
		if err != nil {
			return nil, err
		}
	}
	res, err := DefaultListGroup(ctx, db, in)
	if err != nil {
		return nil, err
	}
	return &ListGroupsResponse{Results: res}, nil
}

// GroupsGroupWithBeforeList called before DefaultListGroup in the default List handler
type GroupsGroupWithBeforeList interface {
	BeforeList(context.Context, *ListGroupRequest, *gorm1.DB) (context.Context, *gorm1.DB, error)
}
type ContactsDefaultServer struct {
	DB *gorm1.DB
}

// Create ...
func (m *ContactsDefaultServer) Create(ctx context.Context, in *CreateContactRequest) (*CreateContactResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ContactsContactWithBeforeCreate); ok {
		var err error
		ctx, db, err = custom.BeforeCreate(ctx, in, db)
		if err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateContact(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	return &CreateContactResponse{Result: res}, nil
}

// ContactsContactWithBeforeCreate called before DefaultCreateContact in the default Create handler
type ContactsContactWithBeforeCreate interface {
	BeforeCreate(context.Context, *CreateContactRequest, *gorm1.DB) (context.Context, *gorm1.DB, error)
}

// Read ...
func (m *ContactsDefaultServer) Read(ctx context.Context, in *ReadContactRequest) (*ReadContactResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ContactsContactWithBeforeRead); ok {
		var err error
		ctx, db, err = custom.BeforeRead(ctx, in, db)
		if err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadContact(ctx, &Contact{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	return &ReadContactResponse{Result: res}, nil
}

// ContactsContactWithBeforeRead called before DefaultReadContact in the default Read handler
type ContactsContactWithBeforeRead interface {
	BeforeRead(context.Context, *ReadContactRequest, *gorm1.DB) (context.Context, *gorm1.DB, error)
}

// Update ...
func (m *ContactsDefaultServer) Update(ctx context.Context, in *UpdateContactRequest) (*UpdateContactResponse, error) {
	var err error
	var res *Contact
	db := m.DB
	if custom, ok := interface{}(in).(ContactsContactWithBeforeUpdate); ok {
		var err error
		ctx, db, err = custom.BeforeUpdate(ctx, in, db)
		if err != nil {
			return nil, err
		}
	}
	if in.GetFields() == nil || len(in.GetFields().GetPaths()) == 0 {
		res, err = DefaultStrictUpdateContact(ctx, in.GetPayload(), db)
	} else {
		res, err = DefaultPatchContact(ctx, in.GetPayload(), in.GetFields(), db)
	}
	if err != nil {
		return nil, err
	}
	return &UpdateContactResponse{Result: res}, nil
}

// ContactsContactWithBeforeUpdate called before DefaultUpdateContact in the default Update handler
type ContactsContactWithBeforeUpdate interface {
	BeforeUpdate(context.Context, *UpdateContactRequest, *gorm1.DB) (context.Context, *gorm1.DB, error)
}

// Delete ...
func (m *ContactsDefaultServer) Delete(ctx context.Context, in *DeleteContactRequest) (*google_protobuf.Empty, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ContactsContactWithBeforeDelete); ok {
		var err error
		ctx, db, err = custom.BeforeDelete(ctx, in, db)
		if err != nil {
			return nil, err
		}
	}
	return &google_protobuf.Empty{}, DefaultDeleteContact(ctx, &Contact{Id: in.GetId()}, db)
}

// ContactsContactWithBeforeDelete called before DefaultDeleteContact in the default Delete handler
type ContactsContactWithBeforeDelete interface {
	BeforeDelete(context.Context, *DeleteContactRequest, *gorm1.DB) (context.Context, *gorm1.DB, error)
}

// List ...
func (m *ContactsDefaultServer) List(ctx context.Context, in *ListContactRequest) (*ListContactsResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ContactsContactWithBeforeList); ok {
		var err error
		ctx, db, err = custom.BeforeList(ctx, in, db)
		if err != nil {
			return nil, err
		}
	}
	res, err := DefaultListContact(ctx, db, in)
	if err != nil {
		return nil, err
	}
	return &ListContactsResponse{Results: res}, nil
}

// ContactsContactWithBeforeList called before DefaultListContact in the default List handler
type ContactsContactWithBeforeList interface {
	BeforeList(context.Context, *ListContactRequest, *gorm1.DB) (context.Context, *gorm1.DB, error)
}

// SendSMS ...
func (m *ContactsDefaultServer) SendSMS(ctx context.Context, in *SMSRequest) (*google_protobuf.Empty, error) {
	return &google_protobuf.Empty{}, nil
}
